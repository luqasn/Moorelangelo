/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.luqasn.stateviz

import kotlin.test.Test
import kotlin.test.assertEquals

class ParserTest {
    @Test
    fun `it parses a state machine without explicit types`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
            }
        """.trimIndent()
        )

        assertEquals(
            StateMachine(emptyList()),
            machine
        )
    }

    @Test
    fun `it parses a state machine with explicit types`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create<A,B,C> {
            }
        """.trimIndent()
        )

        assertEquals(
            StateMachine(emptyList()),
            machine
        )
    }

    @Test
    fun `it parses initial state reference`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
                initialState(SomeState)
            }
        """.trimIndent()
        )

        assertEquals(
            listOf(Statement.InitialState("SomeState")),
            machine.statements
        )
    }

    @Test
    fun `it parses initial state value`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
                initialState("someValue")
            }
        """.trimIndent()
        )

        assertEquals(
            listOf(Statement.InitialState("\"someValue\"")),
            machine.statements
        )
    }


    @Test
    fun `it parses states with types`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
                state<State.Solid> {
                }
                state<State.Liquid> {
                }
            }
        """.trimIndent()
        )

        assertEquals(
            listOf(state("State.Solid"), state("State.Liquid")),
            machine.statements
        )
    }

    @Test
    fun `it parses states with string values`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
                state("a") {
                }
                state("b") {
                }
            }
        """.trimIndent()
        )

        assertEquals(
            listOf(state("a"), state("b")),
            machine.statements
        )
    }

    @Test
    fun `it parses states with Int values`() {
        val machine = singleMachine(
            """
            val stateMachine = StateMachine.create {
                state(1) {
                }
                state(2) {
                }
            }
        """.trimIndent()
        )

        assertEquals(
            listOf(state("1"), state("2")),
            machine.statements
        )
    }

    @Test
    fun `it parses onEnter`() {
        val state = singleState(
            """
            val stateMachine = StateMachine.create {
                state<A> {
                    onEnter {
                        something()
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            state("A", onEnter = listOf("something()")),
            state
        )
    }

    @Test
    fun `it parses onExit`() {
        val state = singleState(
            """
            val stateMachine = StateMachine.create {
                state<A> {
                    onExit {
                        something()
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            state("A", onExit = listOf("something()")),
            state
        )
    }


    @Test
    fun `it parses a transition without a side effect`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<State.Solid> {
                    on<Event.OnMelted> {
                        transitionTo(State.Liquid)
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(event = "Event.OnMelted", targetState = "State.Liquid"),
            transition
        )
    }

    @Test
    fun `it parses a transition with a side effect`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<State.Solid> {
                    on<Event.OnMelted> {
                        transitionTo(State.Liquid, SideEffect.SomeEffect)
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(
                event = "Event.OnMelted",
                targetState = "State.Liquid",
                sideEffect = "SideEffect.SomeEffect"
            ),
            transition
        )
    }

    @Test
    fun `it parses a transition with a string event, target and side-effect`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state("a") {
                    on("hello") {
                        transitionTo("b", "some side-effect")
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(
                event = "hello",
                targetState = "b",
                sideEffect = "some side-effect"
            ),
            transition
        )
    }

    @Test
    fun `it parses a self-transition without a side effect`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<State.Solid> {
                    on<Event.OnMelted> {
                        dontTransition()
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(event = "Event.OnMelted", targetState = "State.Solid"),
            transition
        )
    }


    @Test
    fun `it parses a self-transition with a side effect`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<State.Solid> {
                    on<Event.OnMelted> {
                        dontTransition(SideEffect.SomeEffect)
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(
                event = "Event.OnMelted",
                targetState = "State.Solid",
                sideEffect = "SideEffect.SomeEffect"
            ),
            transition
        )
    }

    @Test
    fun `it parses transition with guard expression`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<WaitingToRetry> {
                    on(lifecycleStart()) {
                        transitionTo(Start)
                    }
                }
            }
            private fun lifecycleStart() =
                any<Event, Event.OnLifecycle.StateChange<*>>().where { state == Lifecycle.State.Started }
        """.trimIndent()
        )

        assertEquals(
            Transition(
                event = "lifecycleStart()",
                targetState = "Start",
            ),
            transition
        )
    }

    @Test
    fun `it parses a transition to a parametrized target state`() {
        val transition = singleTransition(
            """
            val stateMachine = StateMachine.create {
                state<Ready> {
                    on<Connect> {
                        transitionTo(Connecting(session = webSocketSession, retryCount = 0))
                    }
                }
            }
        """.trimIndent()
        )

        assertEquals(
            Transition(
                event = "Connect",
                targetState = "Connecting",
                targetArgs = listOf(
                    "session = webSocketSession",
                    "retryCount = 0"
                )
            ),
            transition
        )
    }
}

private fun singleMachine(code: String) = parse(code).single()
private fun singleState(code: String): Statement.State =
    singleMachine(code).statements.filterIsInstance<Statement.State>().single()

private fun singleTransition(code: String) =
    singleMachine(code).statements.filterIsInstance<Statement.State>().single().transitions.single()

private fun state(name: String, onEnter: List<String> = emptyList(), onExit: List<String> = emptyList()) =
    Statement.State(name, emptyList(), onEnter, onExit)